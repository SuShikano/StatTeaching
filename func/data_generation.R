# ##############################################################################
#' Generating multiple datasets under different assumptions and set-ups
#'
#' @param sample.size
#' @param n.sim
#' @param n.iv
#' @param x.mu specifies the expected values of Xs.
#' @param x.Sigma specifies the variance and covariance of Xs.
#' @param random.seed 
#' @param para specifies the true model's intercept and effect parameter values. For a bivariate regression
#'        model, it contains two elements: intercept and slope. 
#' @param err.dist specifies the distribution form of the errors. Possible values are 
#' "normal" (default) and "uniform".
#' @param err.disp specifies the dispertion of the error distribution. 
#'        For the normal distribution, it specifies the variance.
#'        For the uniform distribution, it specifies the range.
#' @param binary.y logical. If TRUE, y is generated by using the Bernoulli distribution
#'        with the probabilities based on the linear model. If the linear model
#'        predicts the value larger than one/smaller than zero, they are forced to be 
#'        one/zero.
#' @param het logical. If TRUE, the errors have heteroskedasticity. 
#'         Its functional form depending on X is specified by using 'het.delta'.
#' @param het.delta Function of the heteroskedasticity: delta_0 + delta_1 X1 +... delta_J X_j
#' @return A list including all parameter values and generated datasets. 
#'         The generated datasets are saved in the list named 'generated.data'.
# ---------------------------------------------------------------------------- #

data.generation <- function(sample.size=100,
                            n.sim=1000,
                            n.iv=2,
                            x.mu = c(2,5),
                            x.Sigma = diag(c(3,5)),
                            random.seed = NULL,
                            para = c(10,4,-5),
                            err.dist = "normal",
                            err.disp = 25,
                            binary.y = FALSE,
                            het = FALSE,
                            het.delta = c(0.1,0.1,0.1)
){
  
  if (length(x.mu)!=n.iv ) stop("Check the length of x.mu and n.iv.")
  if (!is.matrix(x.Sigma)) stop("x.Sigma has to be a matrix.")
  if (nrow(x.Sigma)!=n.iv| ncol(x.Sigma)!=n.iv ) stop("Check the dimensionality of x.Sigma and the length of n.iv.")
  if (length(para) != (n.iv+1)) stop("Check the length of para and n.iv.")
  if (het) if (length(het.delta)!= (length(x.mu)+1)) stop("Check the length of het.delta, which has the length of the number of independent variables + 1.")
  
  library(MASS)
  if (!is.null(random.seed)) set.seed(random.seed)  
  generated.data <- vector(mode = "list", length = n.sim)
  
  for (i.sim in 1:n.sim){
    X <- mvrnorm(sample.size, mu=x.mu, Sigma=x.Sigma) 
    colnames(X) <- paste0("X",1:n.iv)

    y.hat <- c(cbind(1,X)%*% para)
    
    if (binary.y){
      # generating binary y by using Bernoulli 
      y.hat[y.hat<0] <- 0
      y.hat[y.hat>1] <- 1
      y <- rbinom(n=length(y.hat),1,prob=y.hat)
    }else {
      # In case of heteroskedasticity
      if (het) {
        err.disp.used <- err.disp * c(exp(cbind(1,X) %*% het.delta ) )
        err.disp.used[err.disp.used == Inf] <- max(err.disp.used[is.finite(err.disp.used)]) 
      }else{
        err.disp.used <- err.disp
      }
      # generating continuous y by using normal or uniform distribution
      if (err.dist=="normal") error <- rnorm(sample.size,0,sqrt(err.disp.used))
      if (err.dist=="uniform") error <- runif(sample.size,err.disp.used*(-.5),err.disp.used*(.5))
      y <- y.hat + error
    }

    if (binary.y){
      this.dat <- as.data.frame(cbind(y,X,y.hat))
    }else{
      this.dat <- as.data.frame(cbind(y,X,error))
    }

    generated.data[[i.sim]]  <- this.dat
  }
  
  out.list <- list(sample.size=sample.size,
                   n.sim=n.sim,
                   n.iv=n.iv,
                   x.mu = x.mu,
                   x.Sigma = x.Sigma,
                   random.seed = random.seed,
                   para = para,
                   err.dist = err.dist,
                   err.disp = err.disp,
                   binary.y = binary.y,
                   het = het,
                   generated.data = generated.data)
}







